<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Blog by ParkJaesung]]></title><description><![CDATA[건설환경공학을 전공하는 개발자. 스타트업에 도전하는 것과 새로운 기술들을 공부하는 것을 사랑합니다.]]></description><link>https://lumen.netlify.com</link><generator>RSS for Node</generator><lastBuildDate>Mon, 06 May 2019 10:05:01 GMT</lastBuildDate><item><title><![CDATA[MQTT란?]]></title><description><![CDATA[MQTT의 기본 공부하기]]></description><link>https://lumen.netlify.com/posts/mqtt-basic/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/mqtt-basic/</guid><pubDate>Mon, 06 May 2019 22:40:32 GMT</pubDate><content:encoded>&lt;p&gt;MQTT는 M2M, IOT를 위한 프로토콜로서, 최소한의 전력과 패킷량으로 통신하는 프로토콜입니다. 따라서 IOT와 모바일 어플리케이션 등의 통신에 매우 적합한 프로토콜입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; MQTT는 HTTP, TCP등의 통신과 같이 클라이언트-서버 구조로 이루어지는 것이 아닌, Broker, Publisher, Subscriber 구조로 이루어집니다. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-basic/s213hU6yIRQ6qHiYBgip1kg.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Publisher는 Topic을 발행(publish) 하고, Subscriber는 Topic에 구독(subscribe)합니다. Broker는 이들을 중계하는 역할을 하며, 단일 Topic에 여러 Subscriber가 구독할 수 있기 때문에, 1:N 통신 구축에도 매우 유용합니다. &lt;/p&gt;
&lt;p&gt;MQTT에서 Topic은 /를 사용해서 구성된다.
&lt;img src=&quot;/media/mqtt-basic/Example-of-MQTT-topic-tree.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;따라서 위와 같이 계층을 구성한다면, IOT 센서와 같은 데이터를 관리하기에 매우 용이합니다.&lt;/p&gt;
&lt;p&gt;MQTT는 QoS(Quality of Service)를 제공하는데, 총 3단계로 나뉘어져 있습니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 : 메세지는 한번만 전달되며, 전달이후의 수신과정을 체크하지 않는다. &lt;/li&gt;
&lt;li&gt;1 : 메세지는 한번 이상 전달되고, 핸드셰이킹 과정을 추적하나, 엄격하게 추적하지 않기 때문에 중복수신의 가능성이 있다.&lt;/li&gt;
&lt;li&gt;2 : 메세지는 한번만 전달되고, 핸드셰이킹의 모든 과정을 체크한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;QoS의 단계가 높아질 수록 통신의 품질은 향상되지만, 그에 따라 성능 저하의 가능성이 있으므로. MQTT의 QoS는 프로젝트의 특성에 따라 결정되어야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;mqtt-브로커-구동하기&quot;&gt;&lt;a href=&quot;#mqtt-%EB%B8%8C%EB%A1%9C%EC%BB%A4-%EA%B5%AC%EB%8F%99%ED%95%98%EA%B8%B0&quot; aria-label=&quot;mqtt 브로커 구동하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MQTT 브로커 구동하기&lt;/h2&gt;
&lt;p&gt;MQTT 프로토콜을 구현하는 브로커들은 아래와 같이 여러 것들이 있습니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mosquitto&lt;/li&gt;
&lt;li&gt;HiveMQ&lt;/li&gt;
&lt;li&gt;mosca&lt;/li&gt;
&lt;li&gt;ActiveMQ&lt;/li&gt;
&lt;li&gt;RabbitMQ (Plug-in 형태로 지원)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 중에서도 유명한 브로커 중 하나인 Mosquitto를 사용해봅시다. &lt;/p&gt;
&lt;p&gt;간편하게 실행하기 위해 docker로 실행해보도록 하겠습니다!
공식 이미지 링크 : &lt;a href=&quot;https://hub.docker.com/_/eclipse-mosquitto?tab=description&quot;&gt;https://hub.docker.com/_/eclipse-mosquitto?tab=description&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker을 실행하고, 아래와 같이 실행합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ docker run -it -p 1883:1883 -p 9001:9001 -v /mosquitto/data -v /mosquitto/log eclipse-mosquitto&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-basic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202019-05-03%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.17.31.png&quot;&gt;
(도커로 Mosquitto 구동 결과)&lt;/p&gt;
&lt;p&gt;MQTT-Explorer 라는 툴을 이용해 topic에 publish하고, Python에서 subscribe하여 데이터를 가져오는 예제를 실행해보도록 하곘습니다. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mqtt-explorer.com&quot;&gt;MQTT Explorer | An all-round MQTT client that provides a structured topic overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-basic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202019-05-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.15.26.png&quot;&gt;
MQTT Explorer로 도커로 구동한 브로커 127.0.0.1:1833에 접속하였고, /test/1 topic에 데이터를 publish합니다.&lt;/p&gt;
&lt;p&gt;Python 코드&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; paho&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mqtt&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;client &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; mqtt

&lt;span class=&quot;token comment&quot;&gt;# The callback for when the client receives a CONNACK response from the server.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;on_connect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; userdata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; rc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;“Connected &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; result code “&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;rc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;# Subscribing in on_connect() means that if we lose the connection and&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# reconnect then subscriptions will be renewed.&lt;/span&gt;
    client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;subscribe&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;“&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;test&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;”&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# Topic /seoul/yuokok을 구독한다.&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# The callback for when a PUBLISH message is received from the server.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;on_message&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; userdata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;topic&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;” “&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;payload&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

client &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; mqtt&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Client&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;on_connect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; on_connect
client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;on_message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; on_message

client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;connect&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;“&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt;”&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# - 서버 IP ‘테스트를 위해 test.mosquitto.org’로 지정&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# Blocking call that processes network traffic, dispatches callbacks and&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# handles reconnecting.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Other loop*() functions are available that give a threaded interface and a&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# manual interface.&lt;/span&gt;
client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;loop_forever&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python에서는 Paho 패키지를 사용하여 MQTT 브로커에 접속할 수 있고, /test/1 topic에 subscribe를 하였습니다. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-basic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202019-05-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.17.11.png&quot;&gt;
(MQTT Explorer에서 publish한 결과) &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-basic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202019-05-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.17.19.png&quot;&gt;
(Python에서 subscribe한 데이터를 가져온 결과)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[xcode bundle identifier 변경하기]]></title><description><![CDATA[React Native로 IOS개발을 진행하던 도중 Xcode에서 Bundle Identifier를 변경해야 provisioning profile를 생성할 수 있다는 오류 해결]]></description><link>https://lumen.netlify.com/posts/change-xcode-bundle-identifier/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/change-xcode-bundle-identifier/</guid><pubDate>Sun, 22 Jul 2018 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;xcode bundle identifier 변경
react-native 혹은, ios를 github 저장소에서 받아서 프로젝트를 archive하거나 release를 하려다 보면 Bundler Identifier를 변경해야 provisioning profile을 생성할 수 있다는 에러가 뜬다. 이러한 경우에는 Bundle Identifier를 변경해야 한다. react-native의 ios 폴더안에 있는 xcode workspace 파일을 xcode로 열고 아래의 순서를 따른다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Target -&gt; Build Settings -&gt; product bundle 검색 -&gt; product bundle identifier&lt;/li&gt;
&lt;li&gt;더블 클릭 후 변경&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[react native 'third party' 관련 빌드 에러 해결방법]]></title><description><![CDATA[React Native로 개발할때, 빌드시 발생하는 ‘third-party’와 관련된 에러를 해결해본다.]]></description><link>https://lumen.netlify.com/posts/fix-react-native-third-party-error/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/fix-react-native-third-party-error/</guid><pubDate>Sun, 22 Jul 2018 22:40:32 GMT</pubDate><content:encoded>&lt;p&gt;최근 react-native으로 어플을 개발하게 되면서 관심있는 여러 프로젝트들의 저장소를 내려받아 실행해보고자 하였다. 그러나 의외로 다양한 에러들이 발생하며 빌드에 실패하였다.
그 중 가장 대표적인 에러가 빌드시 발생하는 ‘third-party’와 관련된 에러였다. 에러 발생 로그를 자세히 살펴보니 third-party 라이브러리를 정상적으로 읽을 수 없거나 불러오지 못하는 문제였다.
구글링 결과 react-native에서는 개발환경을 위해 여러 라이브러리를 사용하며 빌드 스크립트를 뜯어보면 github에서 라이브러리 릴리즈 파일을 받도록 되어있다. 그러나 빌드 도중 취소되거나, 네트워크 지연 상의 이유로 github으로 부터 정상적으로 third-party 라이브러리를 받아오지 못하는 경우가 있다. 그러한 경우에는 특정 라이브러리를 삭제하고 수작업으로 라이브러리를 받아서 디렉토리에 저장하던가, 디렉토리 전체를 삭제하고 안정적인 환경에서 빌드를 다시 시작하는 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#!/bin/bash
#boostdir=&amp;quot;`node ./node_modules/boost-lib/bin/boost-lib download -V 1.63`&amp;quot;
#cd &amp;quot;$boostdir&amp;quot;
#./bootstrap.sh
#./b2 headers
set -e
cachedir=&amp;quot;$HOME/.rncache&amp;quot;
mkdir -p &amp;quot;$cachedir&amp;quot;
function fetch_and_unpack () {
    file=$1
    url=$2
    cmd=$3
if [ ! -f &amp;quot;$cachedir/$file&amp;quot; ]; then
        (cd &amp;quot;$cachedir&amp;quot;; curl -J -L -O &amp;quot;$url&amp;quot;)
    fi
dir=$(basename &amp;quot;$file&amp;quot; .tar.gz)
    if [ ! -d &amp;quot;third-party/$dir&amp;quot; ]; then
        (cd third-party;
         echo Unpacking &amp;quot;$cachedir/$file&amp;quot;...
         tar zxf &amp;quot;$cachedir/$file&amp;quot;
cd &amp;quot;$dir&amp;quot;
         eval &amp;quot;${cmd:-true}&amp;quot;)
    fi
}
mkdir -p third-party
SCRIPTDIR=$(dirname &amp;quot;$0&amp;quot;)
fetch_and_unpack glog-0.3.4.tar.gz https://github.com/google/glog/archive/v0.3.4.tar.gz &amp;quot;$SCRIPTDIR/ios-configure-glog.sh&amp;quot;
fetch_and_unpack double-conversion-1.1.5.tar.gz https://github.com/google/double-conversion/archive/v1.1.5.tar.gz
fetch_and_unpack boost_1_63_0.tar.gz https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz
fetch_and_unpack folly-2016.09.26.00.tar.gz https://github.com/facebook/folly/archive/v2016.09.26.00.tar.gz&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 보이는 것과 같이 빌드 스크립트에서 해당 github 주소가 보인다. 위 주소를 통해 직접 다운로드를 하거나, 아래와 같은 절차를 따른다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;~/.rncache 디렉토리 삭제&lt;/li&gt;
&lt;li&gt;react-native run-ios 명령어를 통해 curl: Saved to filename 로그가 정상적으로 나오는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[MQTT 실전 응용하기 - WildCard]]></title><description><![CDATA[MQTT의 WildCard 사용하기]]></description><link>https://lumen.netlify.com/posts/mqtt-wildcard/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/mqtt-wildcard/</guid><pubDate>Sun, 06 May 2018 22:40:32 GMT</pubDate><content:encoded>&lt;h1 id=&quot;mqtt-실전-응용하기---wildcard&quot;&gt;&lt;a href=&quot;#mqtt-%EC%8B%A4%EC%A0%84-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0---wildcard&quot; aria-label=&quot;mqtt 실전 응용하기   wildcard permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MQTT 실전 응용하기 - WildCard&lt;/h1&gt;
&lt;p&gt;MQTT를 활용하여 실제 개발을 진행하려 하니 몇가지 궁금한점과 고려해야할 사항이 생겼다. MQTT를 소개한 글에서 언급한 바와 같이 MQTT는 IoT 프로젝트 통신에 적합하기에 아두이노에서 여러 센서들의 데이터를 받아오는 gateway를 만들어보고자 하였다. 아두이노쪽에서 publish하게 된다면, 클라이언트측에서 해당 topic에 subscribe를 하게 되는데, 구조는 다음과 같이 생각해볼 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-wildcard/mqtt-tmp.001.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;그렇다면 아두이노 기기를 추가하고, 센서를 추가하거나 변경할때마다 topic 관리가 복잡해질것으로 생각되었다. 그래서 생각해본 것이 http서버를 만들때 처럼 동적 url(여기서는 topic)을 사용하는 것이다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/Arduino1/sensor/{sensor_name}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 topic을 설정할 수 있다면, 관리가 더욱 용이할 것으로 생각되었고, mqtt에서는 이를 &lt;code class=&quot;language-text&quot;&gt;WildCard&lt;/code&gt;를 통해서 구현할 수 있었다.&lt;/p&gt;
&lt;p&gt;MQTT에서 WildCard는 크게 두가지 종류가 있다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Single Level : +
Single Level + 는 이름에서 알 수 있다시피 topic에서 한단계의 문자열을 대체하는 문자이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아래 예시를 살펴보자
&lt;img src=&quot;/media/mqtt-wildcard/topic_wildcard_plus.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-wildcard/topic_wildcard_plus_example.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Myhome/groundfloor/livingroom/temperature&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Myhome/groundfloor/kitchen/temperature&lt;/code&gt;와 같이 + 문자의 자리에는 하나의 문자열이 들어간다. &lt;/p&gt;
&lt;p&gt;다만, &lt;code class=&quot;language-text&quot;&gt;Myhome/groundfloor/kitchen/fridge/temperature&lt;/code&gt;에서와 같이, &lt;code class=&quot;language-text&quot;&gt;/kitchen/fridge&lt;/code&gt;처럼 여러 level은 해당되지 않는다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Multi Level : #
Multi Level은 여러 단계의 topic을 subcribe할 수 있도록 한다. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-wildcard/topic_wildcard_hash.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/mqtt-wildcard/topic_wildcard_hash_example.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;1번 예시를 활용해보자면,
&lt;code class=&quot;language-text&quot;&gt;myhome/groundfloor/#/temperature&lt;/code&gt;의 경우에는
Single Level과는 다르게 &lt;code class=&quot;language-text&quot;&gt;myhome/groundfloor/kitchen/fridge/temperature&lt;/code&gt;이 정상적으로 subscribe됨을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;WildCard를 사용해서 MQTT-Explorer와 Python 코드에서 직접 예시를 실행해보자. 그러면 동적으로 다량의 기기와 센서데이터를 관리할때 훨씬 편하게 작업할 수 있음을 확인할 수 있을것이다. &lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;예시 자료 : &lt;a href=&quot;https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/&quot;&gt;MQTT Essentials Part 5: MQTT Topics &amp;#x26; Best Practices&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>